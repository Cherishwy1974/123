<!DOCTYPE html>

<html lang="zh-CN">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>
   02_2.4_求极限的常用方法
  </title>
<link href="https://fonts.googleapis.com" rel="preconnect"/>
<link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect"/>
<link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;600;700&amp;display=swap" rel="stylesheet"/>
<script src="https://d3js.org/d3.v7.min.js">
</script>
<style>
   * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Noto Serif SC', serif;
            background: #1a1a2e;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
        }
        .blackboard {
            width: 100vw;
            height: 100vh;
            background: #1a1a2e;
            position: relative;
            border: 10px solid #795548;
            margin: 0;
        }
        .avatar-container {
            position: fixed;
            top: 60%; left: 50%;
            transform: translate(-50%, -50%);
            width: 975px; height: 1105px;
            overflow: hidden; z-index: 50;
            pointer-events: none; background: transparent;
            border: none; box-shadow: none;
        }
        .wrapper {
            width: 100%; height: 100%;
            background: transparent; pointer-events: auto;
        }
        .content-area {
            position: absolute;
            top: 20px; left: 50px; right: 50px; bottom: 120px;
            z-index: 10; overflow: hidden;
        }
        .page {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            opacity: 0; visibility: hidden;
            transition: all 0.7s ease-in-out;
            padding: 20px;
            display: grid;
            grid-template-columns: 2fr 3fr;
            gap: 20px;
            align-items: center;
        }
        .page.active {
            opacity: 1; visibility: visible;
        }
        /* 封面页特殊样式 - 覆盖grid布局 */
        .page.cover-page {
            display: flex !important;
            grid-template-columns: none !important;
            padding: 0 !important;
            align-items: center !important;
            justify-content: center !important;
        }
        .page.cover-page > div {
            display: flex !important;
        }
        .chalk-text {
            color: #ffffff;
            font-family: 'Noto Serif SC', serif;
            text-rendering: optimizeLegibility;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        .page-title {
            font-size: 22px; font-weight: bold;
            color: #e1bee7; margin-bottom: 1.5rem;
        }
        .text-medium {
            font-size: 18px; margin-bottom: 0.8rem;
            line-height: 1.8; color: #f3e5f5; font-weight: 500;
        }
        .text-medium p {
            margin-bottom: 1.5rem;
        }
        .text-medium strong {
            color: #81c784;
            font-weight: 600;
        }
        .graph-container {
            background: transparent;
            border: none;
            padding: 10px;
            width: 100%; height: 100%;
            display: flex; justify-content: center; align-items: center;
            overflow: visible;
        }
        .subtitle-area {
            position: absolute;
            bottom: 20px; left: 50px; right: 50px;
            height: 50px; background: rgba(0,0,0,0.8);
            border-radius: 8px; display: flex;
            align-items: center; justify-content: center;
            z-index: 60; color: white;
            font-size: 0.9rem; text-align: center;
            padding: 0 20px; line-height: 1.4;
        }
        .control-bar {
            position: fixed;
            left: -9999px;
            top: 50%;
            transform: translateY(-50%);
            width: 270px;
            height: auto;
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(15px);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 12px;
            z-index: 200;
            border-radius: 0 20px 20px 0;
            padding: 25px 20px;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        .control-bar:hover { 
            left: -9999px; 
            box-shadow: 0 12px 40px rgba(0,0,0,0.3); 
        }
        .control-bar::before {
            content: '▶️';
            position: absolute;
            top: 50%;
            right: -30px;
            transform: translateY(-50%);
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            padding: 12px 8px;
            border-radius: 0 15px 15px 0;
            font-size: 0.9rem;
            writing-mode: vertical-lr;
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #333;
        }
        .btn {
            padding: 14px 22px;
            background: rgba(255, 255, 255, 0.25);
            color: #333;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            width: 100%;
            text-align: center;
            backdrop-filter: blur(5px);
            text-shadow: 0 1px 2px rgba(255,255,255,0.3);
        }
        .btn:hover { 
            background: rgba(255, 255, 255, 0.35); 
            transform: translateY(-3px); 
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2); 
        }
        .btn.primary { 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
            color: #fff; 
            text-shadow: 0 1px 2px rgba(0,0,0,0.3); 
        }
        .btn.primary:hover { 
            background: linear-gradient(135deg, #5a6fd8 0%, #6a4190 100%); 
            box-shadow: 0 8px 25px rgba(102,126,234,0.4); 
        }

        /* 统一将图中元素改为白色 */
        .graph-container svg .axis path,
        .graph-container svg .axis line {
            stroke: #ffffff !important;
            stroke-width: 2;
        }
        .graph-container svg .axis text {
            fill: #ffffff !important;
            font-size: 16px;
            font-weight: 500;
        }
        .graph-container svg .label {
            fill: #ffffff !important;
            font-size: 20px;
            font-weight: 600;
        }
        .graph-container svg .grid-line {
            stroke: #ffffff !important;
            stroke-width: 0.5;
            stroke-opacity: 0.3;
        }

        /* 连接状态指示器 */
        .status-indicator {
            position: absolute;
            top: 10px; right: 10px;
            padding: 5px 10px;
            background: rgba(0,0,0,0.5);
            color: white; border-radius: 5px;
            font-size: 12px; z-index: 100;
            transition: opacity 0.3s ease;
        }
        .status-indicator.connected { background: rgba(76, 175, 80, 0.8); }
        .status-indicator.error { background: rgba(244, 67, 54, 0.8); }
        .status-indicator.connecting { background: rgba(255, 152, 0, 0.8); }

        /* 录制模式下隐藏状态指示器和控制栏 */
        .recording-mode .status-indicator {
            opacity: 0; pointer-events: none;
        }
        .recording-mode .control-bar {
            left: -9999px; transition: left 0.5s ease;
        }
  </style>
</head>
<body>
<div class="blackboard">
<div class="status-indicator" id="statusIndicator">
    等待连接
   </div>
<div class="avatar-container">
<div class="wrapper" id="avatarWrapper">
</div>
</div>
<div class="content-area" id="contentArea">
<div class="page active cover-page" data-page="1">
<div style="display: flex !important; width: 100%; height: 100%; align-items: center; justify-content: center;">
<div style="flex: 1; text-align: center; padding: 2rem;">
<h1 style="font-size: 2.2rem; font-weight: bold; color: #f1c40f; text-shadow: 0 0 8px rgba(241, 196, 15, 0.5); margin-bottom: 1rem;">
        求极限的常用方法
       </h1>
<p style="font-size: 1.1rem; color: #9ca3af; margin-bottom: 1.5rem;">
        第2章 视频 2.4
       </p>
<div style="display: inline-block; text-align: left; margin-top: 1.5rem;">
<p style="font-size: 0.95rem; color: #e0e0e0; margin: 0.6rem 0;">
         ✓ 直接代入法
        </p>
<p style="font-size: 0.95rem; color: #e0e0e0; margin: 0.6rem 0;">
         ✓ 因式分解法
        </p>
<p style="font-size: 0.95rem; color: #e0e0e0; margin: 0.6rem 0;">
         ✓ 有理化法
        </p>
<p style="font-size: 0.95rem; color: #e0e0e0; margin: 0.6rem 0;">
         ✓ 等价无穷小替换
        </p>
</div>
</div>
<div style="flex: 1; display: flex; align-items: center; justify-content: center;">
<svg style="width: 100%; max-width: 500px; height: 400px;" viewbox="0 0 600 500">
<defs>
<lineargradient id="grad1" x1="0%" x2="100%" y1="0%" y2="100%">
<stop offset="0%" style="stop-color:#3498db;stop-opacity:1">
</stop>
<stop offset="100%" style="stop-color:#9b59b6;stop-opacity:1">
</stop>
</lineargradient>
</defs>
<text fill="url(#grad1)" font-family="serif" font-size="60" text-anchor="middle" x="300" y="120">
         lim
         <animate attributename="opacity" dur="2s" repeatcount="indefinite" values="0.5;1;0.5">
</animate>
</text>
<line stroke="#3498db" stroke-width="3" x1="100" x2="500" y1="250" y2="250">
</line>
<circle cx="500" cy="250" fill="#e74c3c" r="15">
<animate attributename="r" dur="2s" repeatcount="indefinite" values="10;20;10">
</animate>
</circle>
<path d="M 100 250 Q 300 150 500 250" fill="none" stroke="#2ecc71" stroke-width="3">
<animate attributename="stroke-dasharray" dur="3s" repeatcount="indefinite" values="0,1000;1000,0">
</animate>
</path>
<text fill="#e74c3c" font-size="24" text-anchor="middle" x="500" y="300">
         x→x₀
        </text>
</svg>
</div>
</div>
</div>

<!-- Pages will be dynamically generated here -->
</div>
<div class="subtitle-area" id="subtitleArea">
    欢迎学习求极限的常用方法！点击"开始讲课"启动虚拟人讲师。
   </div>
<div class="control-bar">
<div style="color: white; margin-bottom: 1rem; text-align: center; font-size: 12px;">
     第
     <span id="currentPage">
      1
     </span>
     页 / 共
     <span id="totalPages">
      19
     </span>
     页
    </div>
<div id="connectionStatus" style="color: #ffab40; margin-bottom: 1rem; text-align: center; font-size: 11px;">
     虚拟人未连接
    </div>
<button class="btn" onclick="previousPage()">
     ⬅️ 上一页
    </button>
<button class="btn primary" id="startBtn" onclick="startTeaching()">
     🎀 开始讲课
    </button>
<button class="btn" onclick="nextPage()">
     下一页 ➡️
    </button>
<button class="btn" onclick="restart()">
     🔄 重新开始
    </button>
<button class="btn" id="autoPlayBtn" onclick="startAutoPlay()" style="background: linear-gradient(135deg, #2196f3, #1976d2);">
     🎬 自动播放
    </button>
<div style="color: #ffab40; margin-top: 0.5rem; text-align: center; font-size: 10px; line-height: 1.2;">
     💡 录制提示：
     <br/>
     点击自动播放后立即开始录屏
     <br/>
     系统会自动完成全部演示
    </div>
</div>
</div>
<script>
   window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                packages: ['base', 'ams']
            },
            startup: {
                pageReady: () => {
                    console.log('MathJax is ready.');
                    return MathJax.startup.defaultPageReady();
                }
            },
            options: {
                processHtmlClass: 'tex2jax_process',
                ignoreHtmlClass: 'tex2jax_ignore'
            }
        };
  </script>
<script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
<!-- 讯飞官方SDK -->
<script type="module">
        // 播放完成标记（供OBS检测）
        window.playbackFinished = false;

   try {
            const { default: AvatarPlatform, SDKEvents, PlayerEvents, RecorderEvents, UserMedia } = await import('./avatar-sdk-web_3.1.2.1002/index.js');
            window.AvatarPlatform = AvatarPlatform;
            window.SDKEvents = SDKEvents;
            window.PlayerEvents = PlayerEvents;
            window.RecorderEvents = RecorderEvents;
            window.UserMedia = UserMedia;
            console.log('✅ 讯飞官方SDK模块已加载');
            console.log('SDK版本:', AvatarPlatform.getVersion());
        } catch (error) {
            console.error('❌ SDK模块加载失败:', error);
            // 降级处理：创建模拟的AvatarPlatform
            window.AvatarPlatform = class {
                constructor(options) {
                    this.events = {};
                    this.options = options;
                    console.log("模拟SDK已初始化");
                }
                on(event, callback) {
                    this.events[event] = callback;
                    return this;
                }
                setApiInfo(info) {
                    this.apiInfo = info;
                    console.log("API Info set:", info);
                }
                setGlobalParams(params) {
                    this.globalParams = params;
                    console.log("Global Params set:", params);
                }
                async start(config) {
                    console.log("模拟启动虚拟人");
                    setTimeout(() => {
                        this.events.connected?.({ message: "模拟连接成功" });
                    }, 1000);
                }
                async writeText(text, options) {
                    console.log("模拟播放文本:", text);
                    return Promise.resolve();
                }
                async writeCmd(type, actionId) {
                    console.log(`模拟执行动作: ${type} - ${actionId}`);
                    return Promise.resolve();
                }
                stop() {
                    console.log("模拟停止虚拟人");
                }
                destroy() {
                    console.log("模拟销毁虚拟人");
                }
                static getVersion() {
                    return "模拟版本 1.0.0";
                }
            };
        }
        window.dispatchEvent(new CustomEvent('sdkReady'));
  </script>
<script>
   let avatarPlatform = null;
        let isConnected = false;
        let isTeaching = false;
        let currentPage = 1;
        const totalPages = 19;

        const boardContent = [
            // === 方法一：直接代入法 (4页) ===
            {
                title: "方法一：直接代入法 - 问题引入",
                text: "<p>我们先来看最简单的极限求解方法。</p><p>求函数 $f(x) = 2x+1$</p><p>当 $x$ 趋近于 $3$ 时的极限。</p><p><strong>数学表达式为：</strong></p><div class='tex2jax_process'>$$\\lim_{x \\to 3} (2x+1) = ?$$</div>"
            },
            {
                title: "观察函数性质",
                text: "<p>函数 $f(x) = 2x+1$ 是一个简单的线性函数。</p><p>它的图像是一条<strong>连续的直线</strong>，在定义域内没有任何中断或跳跃。</p><p>这是应用直接代入法的<strong>必要条件</strong>。</p>"
            },
            {
                title: "直接代入求解",
                text: "<p>将 $x=3$ 代入 $f(x)=2x+1$：</p><p>$f(3) = 2 \\times (3) + 1$</p><p>$= 6 + 1$</p><p>$= 7$</p><p>我们得到了一个<strong>确定的数值</strong>。</p>"
            },
            {
                title: "结论",
                text: "<p>因为我们通过直接代入得到了一个确定的值 $7$，所以这个值就是函数当 $x$ 趋近于 $3$ 时的极限。</p><p><strong>最终答案：</strong></p><div class='tex2jax_process'>$$\\lim_{x \\to 3} (2x+1) = 7$$</div><p><strong>适用范围：</strong>函数在该点连续时，可直接代入求极限。</p>"
            },

            // === 方法二：因式分解法 (5页) ===
            {
                title: "方法二：因式分解法 - 问题引入",
                text: "<p>现在我们来处理更复杂的情况。</p><p>求 $\\displaystyle\\lim_{x \\to 2} \\frac{x^2 - 4}{x - 2}$</p><p>这是一个<strong>分式极限</strong>的典型例题。</p><p>尝试直接代入会遇到什么问题呢？</p>"
            },
            {
                title: "发现未定式",
                text: "<p>首先，我们尝试将 $x=2$ 直接代入表达式中。</p><p>$\\frac{2^2 - 4}{2 - 2} = \\frac{4 - 4}{2 - 2} = \\frac{0}{0}$</p><p><strong>这是一个\"0/0\"型未定式，无法直接得出结果。</strong></p><p>我们需要使用因式分解来化简。</p>"
            },
            {
                title: "因式分解",
                text: "<p>对于\"0/0\"型，我们尝试对分子进行<strong>因式分解</strong>。</p><p>利用平方差公式：</p><p>$x^2 - 4 = (x-2)(x+2)$</p><p>这样我们就能找到分子分母的<strong>公因式</strong>。</p>"
            },
            {
                title: "约去公因式",
                text: "<p>将分解后的式子代回原极限：</p><p>$\\displaystyle\\lim_{x \\to 2} \\frac{(x-2)(x+2)}{x-2}$</p><p>因为 $x \\to 2$ 但 $x \\neq 2$，所以 $(x-2)$ 不为零，可以<strong>约分</strong>。</p><p>约分后：$\\displaystyle\\lim_{x \\to 2} (x+2)$</p>"
            },
            {
                title: "再次代入并得出结论",
                text: "<p>化简后，我们可以再次进行直接代入：</p><p>$2+2=4$</p><p><strong>最终答案：</strong></p><p>$\\displaystyle\\lim_{x \\to 2} \\frac{x^2 - 4}{x - 2} = 4$</p><p><strong>适用范围：</strong>分式的 0/0 型未定式，通过因式分解消除零因子。</p>"
            },

            // === 方法三：根式有理化 (5页) ===
            {
                title: "方法三：根式有理化 - 问题引入",
                text: "<p>当极限问题中包含根式时，我们需要使用有理化方法。</p><p>求 $\\displaystyle\\lim_{x \\to 0} \\frac{\\sqrt{x + 1} - 1}{x}$</p><p>尝试直接代入会发现：</p><p>$\\frac{\\sqrt{0 + 1} - 1}{0} = \\frac{1 - 1}{0} = \\frac{0}{0}$</p><p>又是一个<strong>\"0/0\"型未定式</strong>，但这次包含根式。</p>"
            },
            {
                title: "乘以共轭根式",
                text: "<p>当表达式中含有根式时，我们可以通过乘以它的<strong>共轭根式</strong>来消除根号。</p><p>$\\sqrt{x+1}-1$ 的共轭根式是 $\\sqrt{x+1}+1$</p><p>我们将分子分母同时乘以它：</p><p>$\\displaystyle\\lim_{x \\to 0} \\frac{\\sqrt{x+1}-1}{x} \\cdot \\frac{\\sqrt{x+1}+1}{\\sqrt{x+1}+1}$</p>"
            },
            {
                title: "化简表达式",
                text: "<p>分子利用平方差公式 $(a-b)(a+b)=a^2-b^2$ 进行化简：</p><p>$(\\sqrt{x+1}-1)(\\sqrt{x+1}+1) = (\\sqrt{x+1})^2 - 1^2 = (x+1)-1 = x$</p><p>于是原式变为：</p><p>$\\displaystyle\\lim_{x \\to 0} \\frac{x}{x(\\sqrt{x+1}+1)}$</p><p>分子上的根号成功消除！</p>"
            },
            {
                title: "约分并代入",
                text: "<p>化简后，我们发现分子分母有公因式 $x$，可以约去：</p><p>$\\displaystyle\\lim_{x \\to 0} \\frac{1}{\\sqrt{x+1}+1}$</p><p>现在，再次直接代入 $x=0$：</p><p>$\\frac{1}{\\sqrt{0+1}+1} = \\frac{1}{1+1} = \\frac{1}{2}$</p>"
            },
            {
                title: "得出结论",
                text: "<p>我们通过根式有理化，成功消除了零因子，得到了一个确定的数值 $\\frac{1}{2}$。</p><p><strong>最终答案：</strong></p><p>$\\displaystyle\\lim_{x \\to 0} \\frac{\\sqrt{x + 1} - 1}{x} = \\frac{1}{2}$</p><p><strong>适用范围：</strong>含根式的 0/0 型未定式，通过乘以共轭根式进行有理化。</p>"
            },

            // === 方法四：通分法 (4页) ===
            {
                title: "方法四：通分法 - ∞-∞型未定式",
                text: "<p>当遇到 $\\infty - \\infty$ 型未定式时，<strong>通分</strong>是关键的第一步。</p><p>例题：$\\displaystyle\\lim_{x \\to \\infty} \\left(\\frac{1}{x - 1} - \\frac{1}{x + 1}\\right)$</p><p><strong>策略：</strong>通过通分将两个分式合并为一个分式，再进行化简。</p>"
            },
            {
                title: "通分与合并",
                text: "<p>我们将两个分式通分，得到相同的分母 $(x-1)(x+1)$：</p><p>$\\displaystyle\\lim_{x \\to \\infty} \\frac{(x + 1) - (x - 1)}{(x - 1)(x + 1)}$</p><p><strong>分子化简：</strong></p><p>$(x + 1) - (x - 1) = x + 1 - x + 1 = 2$</p><p>合并后：$\\displaystyle\\lim_{x \\to \\infty} \\frac{2}{x^2 - 1}$</p>"
            },
            {
                title: "求解极限",
                text: "<p>化简后，我们得到了标准的 $\\frac{常数}{\\infty}$ 型极限。</p><p>$\\frac{2}{\\infty^2 - 1} = \\frac{2}{\\infty} = 0$</p><p><strong>最终答案：</strong></p><p>$\\displaystyle\\lim_{x \\to \\infty} \\left(\\frac{1}{x - 1} - \\frac{1}{x + 1}\\right) = 0$</p>"
            },
            {
                title: "总结：四种常用方法",
                text: "<p><strong>方法选择指南：</strong></p><p><strong>1. 直接代入法：</strong>函数在该点连续 → 直接代入</p><p><strong>2. 因式分解法：</strong>0/0 型分式未定式 → 因式分解约分</p><p><strong>3. 根式有理化：</strong>含根式的 0/0 型 → 乘以共轭根式</p><p><strong>4. 通分法：</strong>∞-∞ 型未定式 → 通分合并化简</p><p><strong>核心思想：</strong>将未定式转化为确定形式，再求解极限。</p>"
            }
        ];

        const subtitleScript = {
            1: "同学们好，今天我们来系统学习求解极限问题的四种常用代数方法。分别是直接代入法、因式分解法、根式有理化和通分法。接下来我们将通过具体例题，逐一掌握这些方法。",

            // 直接代入法 (2-5)
            2: "首先我们学习最简单的方法——直接代入法。我们要计算的是函数 f(x) = 2x+1，当x无限趋近于3时的极限值。",
            3: "解题的第一步，是先观察这个函数。我们看到，f(x) = 2x+1 是一个线性函数，它的图像是一条连续不断的直线。这一点对于我们选择解法至关重要。",
            4: "正因为函数是连续的，我们可以使用最简单的方法——直接代入法。把x替换成3，得到二乘以三，再加一。也就是六加一，结果等于七。",
            5: "由于直接代入得到了一个确定的数值7，我们就可以得出结论：函数 2x+1 在 x 趋近于 3 时的极限就是7。这就是直接代入法的应用，非常直观。",

            // 因式分解法 (6-10)
            6: "现在我们来学习第二种方法——因式分解法。这个方法用于处理分式极限问题。我们将通过求解这个分式极限的例题来掌握它。",
            7: "求解极限的第一步，总是尝试直接代入。我们把 x 等于 2 代入，会发现分子是 4 减 4 等于 0，分母是 2 减 2 等于 0。这就得到了 0 除以 0 的形式，这是一个未定式，说明我们需要用更巧妙的方法。",
            8: "面对 0/0 型未定式，因式分解是我们的有力武器。观察分子 x 的平方减 4，我们可以利用平方差公式，将它分解为 x 减 2 乘以 x 加 2。这样就能找到分子分母的公因式。",
            9: "现在，我们将分解后的式子代回原极限。大家看，分子和分母都出现了公因式 x 减 2。因为求极限的过程中，x 只是无限趋近于2，但永远不等于2，所以 x 减 2 这个因子不为零，我们可以安全地将它约去。",
            10: "约去公因式后，原来复杂的分式极限，就简化成了一个非常简单的整式极限。我们再次使用直接代入法，将 x 等于 2 代入，得到 2 加 2 等于 4。这就是因式分解法解决未定式极限的完整过程。",

            // 根式有理化 (11-15)
            11: "第三种方法是根式有理化。同学们，当极限问题中包含根式时，我们需要使用这个方法。大家看，这个函数的分子部分包含了一个根式，直接代入会得到 0/0 型未定式。",
            12: "处理根式的诀窍，就是乘以它的共轭根式。对于根号下x+1再减1，它的共轭形式就是根号下x+1再加1。为了保持分式的值不变，我们要在分子和分母上同时乘以这个共轭根式。",
            13: "现在看分子，它变成了(a-b)乘以(a+b)的形式，正好是平方差公式。计算结果是x+1再减1，就等于x。这样一来，我们就成功地消除了分子上的根号！",
            14: "化简之后，我们惊喜地发现，分子上的x和分母中的x可以相互约去。极限问题就变成了一个非常简单的分式。我们再次将x等于0代入，得到根号1加1分之一，也就是二分之一。",
            15: "通过乘以共轭根式进行有理化，我们巧妙地解决了0/0型未定式，并得到了最终答案：二分之一。这个方法在处理带根号的极限问题时非常有效。",

            // 通分法 (16-19)
            16: "最后一种方法是通分法，用于处理无穷减无穷型未定式。当 x 趋向于无穷大时，两个分式都趋向于0，它们的差值形式为未定式。解决这类问题的关键技巧就是通分。",
            17: "首先，我们找到两个分式的最小公分母，也就是x减1乘以x加1。然后我们将两个分式通分并合并分子，得到x加1减去x减1，化简后得到2。",
            18: "化简后，我们得到一个非常简单的分式：x的平方减1分之2。现在，我们再次尝试将x趋向于无穷大代入，分母会变得无限大，因此整个分式的结果趋向于0。问题就解决了。",
            19: "好的同学们，今天我们系统学习了求解极限的四种常用方法。每种方法都有其特定的适用场景。直接代入法用于连续函数，因式分解法用于分式的 0/0 型未定式，根式有理化用于含根式的未定式，通分法用于无穷减无穷型。掌握这些方法，我们就能应对大部分的极限求解问题了。"
        };

        const autoPlayDurations = {
            1: 14000,   // 引导页
            2: 10000,   // 直接代入法-1
            3: 12000,   // 直接代入法-2
            4: 10000,   // 直接代入法-3
            5: 12000,   // 直接代入法-4
            6: 10000,   // 因式分解法-1
            7: 18000,   // 因式分解法-2
            8: 15000,   // 因式分解法-3
            9: 20000,   // 因式分解法-4
            10: 15000,  // 因式分解法-5
            11: 12000,  // 根式有理化-1
            12: 18000,  // 根式有理化-2
            13: 15000,  // 根式有理化-3
            14: 14000,  // 根式有理化-4
            15: 12000,  // 根式有理化-5
            16: 12000,  // 通分法-1
            17: 12000,  // 通分法-2
            18: 12000,  // 通分法-3
            19: 18000   // 总结
        };

        // 状态更新函数
        function updateStatus(message, type = 'normal') {
            const indicator = document.getElementById('statusIndicator');
            const connectionStatus = document.getElementById('connectionStatus');

            if (indicator) {
                indicator.textContent = message;
                indicator.className = 'status-indicator';
                if (type === 'connected') {
                    indicator.classList.add('connected');
                } else if (type === 'error') {
                    indicator.classList.add('error');
                } else if (type === 'connecting') {
                    indicator.classList.add('connecting');
                }
            }

            if (connectionStatus) {
                connectionStatus.textContent = message;
                connectionStatus.style.color = type === 'connected' ? '#81c784' :
                                              type === 'error' ? '#f44336' : '#ffab40';
            }
        }

        // 等待SDK加载完成
        function waitForSDK() {
            return new Promise((resolve, reject) => {
                if (typeof AvatarPlatform !== 'undefined') {
                    resolve();
                    return;
                }

                const timeout = setTimeout(() => {
                    reject(new Error('SDK加载超时，请刷新页面重试'));
                }, 10000);

                window.addEventListener('sdkReady', function handler() {
                    clearTimeout(timeout);
                    window.removeEventListener('sdkReady', handler);
                    resolve();
                });
            });
        }

        document.addEventListener('DOMContentLoaded', () => {
            const contentArea = document.getElementById('contentArea');
            
            // 封面页已经在HTML中存在，不需要动态创建

            // 创建内容页
            boardContent.forEach((content, i) => {
                const page = document.createElement('div');
                page.className = 'page';
                page.dataset.page = i + 2;
                page.innerHTML = `
                    <div class="chalk-text">
                        <div class="page-title">${content.title}</div>
                        <div class="text-medium">${content.text}</div>
                    </div>
                    <div class="graph-container">
                        <svg id="viz-${i+2}" width="100%" height="100%"></svg>
                    </div>
                `;
                contentArea.appendChild(page);
            });

            // 设置总页数（+1因为有封面）
            document.getElementById('totalPages').textContent = totalPages + 1;
            switchToPage(1, false);
            console.log('✨ 极限教学系统初始化完成');

            // 🚀 自动启动播放 - 延迟3秒后自动开始
            setTimeout(() => {
                console.log('🚀 自动启动播放...');
                startAutoPlay();
            }, 3000);
        });

        function switchToPage(pageNum, shouldSpeak = true) {
            if (pageNum < 1 || pageNum > totalPages + 1) return;
            currentPage = pageNum;
            document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
            document.querySelector(`[data-page="${pageNum}"]`).classList.add('active');
            updatePageInfo();

            setTimeout(() => {
                drawPageGraph(pageNum);
                if(window.MathJax && window.MathJax.typeset) {
                    window.MathJax.typeset();
                }
            }, 50);

            if (shouldSpeak && !isAutoPlaying) {
                speakContent(pageNum);
            }
        }

        // 静默页面切换
        function switchToPageSilent(pageNum) {
            if (pageNum < 1 || pageNum > totalPages) {
                console.log(`❌ 页面切换失败：页码${pageNum}超出范围(1-${totalPages})`);
                return;
            }

            console.log(`🔄 开始切换到第${pageNum}页...`);

            const allPages = document.querySelectorAll('.page');
            allPages.forEach(page => page.classList.remove('active'));

            const targetPage = document.querySelector(`[data-page="${pageNum}"]`);
            if (targetPage) {
                targetPage.classList.add('active');
                currentPage = pageNum;
                updatePageInfo();
                console.log(`✅ 成功切换到第${pageNum}页`);

                targetPage.offsetHeight;

                setTimeout(() => {
                    drawPageGraph(pageNum);
                    console.log(`🎨 第${pageNum}页图像绘制完成`);
                }, 300);
            } else {
                console.log(`❌ 未找到第${pageNum}页的DOM元素`);
            }
        }

        function drawPageGraph(pageNum) {
            // 封面页（第1页）不需要绘制图像，已有静态SVG
            if (pageNum === 1) {
                console.log('✅ 第1页是封面页，跳过图像绘制');
                return;
            }

            const svg = d3.select(`#viz-${pageNum}`);
            if (svg.empty()) {
                console.log(`⚠️ 未找到#viz-${pageNum}的SVG元素`);
                return;
            }

            svg.selectAll("*").remove();

            const container = svg.node().parentNode;
            const width = Math.max(container.clientWidth - 20, 300);
            const height = Math.max(container.clientHeight - 20, 200);
            svg.attr('viewBox', `0 0 ${width} ${height}`)
               .attr('preserveAspectRatio', 'xMidYMid meet');

            // 根据页码选择绘图函数
            if (pageNum >= 2 && pageNum <= 5) {
                drawDirectSubstitution(svg, width, height, pageNum - 1);
            } else if (pageNum >= 6 && pageNum <= 10) {
                drawFactorization(svg, width, height, pageNum - 5);
            } else if (pageNum >= 11 && pageNum <= 15) {
                drawRationalization(svg, width, height, pageNum - 10);
            } else if (pageNum >= 16 && pageNum <= 18) {
                drawCommonDenominator(svg, width, height, pageNum - 15);
            } else if (pageNum === 19) {
                drawSummary(svg, width, height);
            }
        }

        // === 图形绘制函数 ===

        function drawMethodsOverview(svg, width, height) {
            const g = svg.append("g").attr("transform", `translate(${width/2}, ${height/2})`);
            const fontSize = Math.min(width/15, height/10, 32);

            const methods = [
                { text: "直接代入法", y: -height/4, color: "#81c784" },
                { text: "因式分解法", y: -height/12, color: "#ffab40" },
                { text: "根式有理化", y: height/12, color: "#22d3ee" },
                { text: "通分法", y: height/4, color: "#e1bee7" }
            ];

            methods.forEach((method, i) => {
                const text = g.append("text")
                    .attr("y", method.y)
                    .attr("font-size", fontSize + "px")
                    .attr("fill", method.color)
                    .attr("text-anchor", "middle")
                    .attr("font-weight", "600")
                    .text(`${i+1}. ${method.text}`)
                    .attr("opacity", 0);

                text.transition().delay(i * 300).duration(800).attr("opacity", 1);
            });
        }

        function drawDirectSubstitution(svg, width, height, step) {
            const g = svg.append("g").attr("transform", `translate(${width/2}, ${height/2})`);
            const fontSize = Math.min(width * 0.08, height * 0.12, 40);

            if (step === 1) {
                // 问题展示
                const gradient = svg.append("defs").append("linearGradient")
                    .attr("id", "grad1")
                    .attr("x1", "0%").attr("y1", "0%")
                    .attr("x2", "100%").attr("y2", "0%");
                gradient.append("stop").attr("offset", "0%").style("stop-color", "#e1bee7");
                gradient.append("stop").attr("offset", "100%").style("stop-color", "#81c784");

                g.append("text")
                    .attr("x", -fontSize * 1.5).attr("y", -10)
                    .attr("text-anchor", "middle")
                    .attr("font-size", fontSize + "px")
                    .attr("font-weight", "bold")
                    .attr("fill", "url(#grad1)")
                    .text("lim");

                g.append("text")
                    .attr("x", -fontSize * 1.5).attr("y", fontSize * 0.4)
                    .attr("text-anchor", "middle")
                    .attr("font-size", fontSize * 0.6 + "px")
                    .attr("fill", "#ffab40")
                    .text("x→3");

                g.append("text")
                    .attr("x", fontSize * 0.5).attr("y", -10)
                    .attr("text-anchor", "start")
                    .attr("font-size", fontSize + "px")
                    .attr("font-weight", "bold")
                    .attr("fill", "url(#grad1)")
                    .text("(2x+1) = ?");
            } else if (step === 2) {
                // 函数图像
                const margin = { top: 40, right: 40, bottom: 40, left: 40 };
                const w = width - margin.left - margin.right;
                const h = height - margin.top - margin.bottom;
                const gAxis = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);

                const x = d3.scaleLinear().domain([-1, 5]).range([0, w]);
                const y = d3.scaleLinear().domain([-1, 12]).range([h, 0]);

                const xAxis = gAxis.append("g")
                    .attr("transform", `translate(0,${y(0)})`)
                    .call(d3.axisBottom(x).tickSizeOuter(0));
                xAxis.selectAll("path, line").attr("stroke", "#ffffff").attr("stroke-width", 2);
                xAxis.selectAll("text").attr("fill", "#ffffff").attr("font-size", "16px");

                const yAxis = gAxis.append("g")
                    .attr("transform", `translate(${x(0)},0)`)
                    .call(d3.axisLeft(y).tickSizeOuter(0));
                yAxis.selectAll("path, line").attr("stroke", "#ffffff").attr("stroke-width", 2);
                yAxis.selectAll("text").attr("fill", "#ffffff").attr("font-size", "16px");

                const line = gAxis.append("line")
                    .attr("x1", x(-1)).attr("y1", y(-1*2+1))
                    .attr("x2", x(5)).attr("y2", y(5*2+1))
                    .attr("stroke", "#81c784")
                    .attr("stroke-width", 4);
            } else if (step === 3 || step === 4) {
                // 计算过程和结果
                g.append("text")
                    .attr("y", -fontSize/2)
                    .attr("font-size", fontSize + "px")
                    .attr("fill", "white")
                    .attr("text-anchor", "middle")
                    .text("2 × 3 + 1 = 7");
            }
        }

        function drawFactorization(svg, width, height, step) {
            // 因式分解法的图形
            const g = svg.append("g").attr("transform", `translate(${width/2}, ${height/2})`);
            const fontSize = Math.min(width * 0.06, height * 0.1, 36);

            if (step === 1 || step === 5) {
                // 显示极限表达式
                g.append("text")
                    .attr("y", 0)
                    .attr("font-size", fontSize + "px")
                    .attr("fill", "white")
                    .attr("text-anchor", "middle")
                    .text("(x² - 4) / (x - 2)");
            }
        }

        function drawRationalization(svg, width, height, step) {
            // 根式有理化的图形
            const g = svg.append("g").attr("transform", `translate(${width/2}, ${height/2})`);
            const fontSize = Math.min(width * 0.06, height * 0.1, 32);

            g.append("text")
                .attr("y", 0)
                .attr("font-size", fontSize + "px")
                .attr("fill", "white")
                .attr("text-anchor", "middle")
                .text("√(x+1) - 1");
        }

        function drawCommonDenominator(svg, width, height, step) {
            // 通分法的图形
            const g = svg.append("g").attr("transform", `translate(${width/2}, ${height/2})`);
            const fontSize = Math.min(width * 0.06, height * 0.1, 36);

            if (step === 1) {
                g.append("text")
                    .attr("y", 0)
                    .attr("font-size", fontSize + "px")
                    .attr("fill", "white")
                    .attr("text-anchor", "middle")
                    .text("1/(x-1) - 1/(x+1)");
            } else if (step === 2) {
                g.append("text")
                    .attr("y", 0)
                    .attr("font-size", fontSize + "px")
                    .attr("fill", "#81c784")
                    .attr("text-anchor", "middle")
                    .text("2 / (x²-1)");
            } else if (step === 3) {
                g.append("text")
                    .attr("y", 0)
                    .attr("font-size", fontSize * 1.5 + "px")
                    .attr("fill", "#81c784")
                    .attr("text-anchor", "middle")
                    .text("0");
            }
        }

        function drawSummary(svg, width, height) {
            const g = svg.append("g").attr("transform", `translate(${width/2}, ${height/2})`);
            const fontSize = Math.min(width/18, height/12, 28);

            const methods = [
                { text: "直接代入 → 连续函数", y: -height/3.5, color: "#81c784" },
                { text: "因式分解 → 0/0型", y: -height/10, color: "#ffab40" },
                { text: "根式有理化 → 含根式", y: height/10, color: "#22d3ee" },
                { text: "通分法 → ∞-∞型", y: height/3.5, color: "#e1bee7" }
            ];

            methods.forEach((method, i) => {
                g.append("text")
                    .attr("y", method.y)
                    .attr("font-size", fontSize + "px")
                    .attr("fill", method.color)
                    .attr("text-anchor", "middle")
                    .attr("font-weight", "500")
                    .text(method.text)
                    .attr("opacity", 0)
                    .transition().delay(i * 300).duration(800).attr("opacity", 1);
            });
        }

        // === 虚拟人控制 ===

        async function startTeaching() {
            const startBtn = document.getElementById('startBtn');
            startBtn.textContent = '🔄 启动中...';
            startBtn.disabled = true;

            try {
                console.log('⏳ 等待SDK模块加载...');
                updateStatus('等待SDK加载...', 'connecting');
                await waitForSDK();

                console.log('✅ 讯飞官方SDK已加载');
                updateStatus('SDK已加载', 'connecting');

                if(avatarPlatform) {
                    avatarPlatform.destroy();
                }

                avatarPlatform = new AvatarPlatform({
                    useInlinePlayer: true
                });

                avatarPlatform
                    .on('connected', (initResp) => {
                        console.log('🎉 虚拟人连接成功！', initResp);
                        isConnected = true;
                        isTeaching = true;
                        updateStatus('已连接', 'connected');
                        startBtn.textContent = '💖 虚拟人已就绪';
                        startBtn.disabled = false;

                        setTimeout(() => {
                            speakContent(1);
                        }, 1000);
                    })
                    .on('disconnected', (err) => {
                        console.log('🔌 虚拟人连接断开');
                        isConnected = false;
                        isTeaching = false;
                        updateStatus('连接断开', 'error');
                        startBtn.textContent = '🎀 开始讲课';
                        startBtn.disabled = false;
                        if (err) {
                            console.error('❌ 连接异常断开:', err);
                        }
                    })
                    .on('error', (error) => {
                        console.error('❌ 虚拟人错误:', error);
                        updateStatus('错误: ' + error.message, 'error');
                        startBtn.textContent = '❌ 连接失败';
                        startBtn.disabled = false;
                        isTeaching = false;
                        isConnected = false;
                    });

                avatarPlatform.setApiInfo({
                    appId: '1af9f6ce',                                    // 数学讲解 AppID
                    apiKey: 'fb9e639101a96b2e8f55ff7598947a4d',             // 数学讲解 API密钥
                    apiSecret: 'YTY3ODBiYTUwODViOWRjZjc5NWQ0YWNm',       // 数学讲解 API密钥
                    sceneId: '238962977817104384',                       // 数学讲解 场景ID
                    serverUrl: 'wss://avatar.cn-huadong-1.xf-yun.com/v1/interact'
                });

                avatarPlatform.setGlobalParams({
                    stream: {
                        protocol: 'xrtc',
                        alpha: 1,
                        bitrate: 1000000,
                        fps: 25
                    },
                    avatar: {
                        avatar_id: '110332017',
                        width: 1920,
                        height: 1080,
                        scale: 1,
                        move_h: 0,
                        move_v: 0,
                        audio_format: 1
                    },
                    tts: {
                        vcn: 'x4_yiting',
                        speed: 50,
                        pitch: 50,
                        volume: 100
                    },
                    avatar_dispatch: {
                        interactive_mode: 1,
                        content_analysis: 0
                    }
                });

                await avatarPlatform.start({
                    wrapper: document.getElementById('avatarWrapper')
                });

                console.log('🎓 虚拟人教学系统启动完成');

            } catch (error) {
                console.error('❌ 启动失败:', error);
                updateStatus('启动失败', 'error');
                startBtn.textContent = '🔄 重试';
                startBtn.disabled = false;

                alert(`启动失败：${error.message}\n\n请检查控制台获取详细错误信息。`);
            }
        }

        async function performVirtualAction(actionId) {
            if (!isTeaching || !isConnected || !avatarPlatform) {
                console.log('⚠️ 虚拟人未连接，跳过动作执行');
                return;
            }

            try {
                await avatarPlatform.writeCmd("action", actionId);
                console.log(`✅ 执行动作: ${actionId}`);
            } catch (error) {
                console.error(`❌ 动作执行失败 (${actionId}):`, error);
            }
        }

        function getActionsForPage(pageNum) {
            const actions = ['A_RLH_welcome_O', 'A_LH_introduced_O', 'A_RH_please1_O', 'A_RLH_emphasize_O', 'A_U_No_pointing_O'];
            return actions[pageNum % actions.length];
        }

        async function speakContent(pageNum) {
            console.log(`🔍 检查播放条件: isTeaching=${isTeaching}, isConnected=${isConnected}, avatarPlatform=${!!avatarPlatform}`);

            if (!isTeaching || !isConnected || !avatarPlatform) {
                console.log('⚠️ 虚拟人未连接或未开始教学，跳过语音播报');
                return;
            }

            const content = subtitleScript[pageNum];
            if (!content) return;

            try {
                const actionId = getActionsForPage(pageNum);
                if (actionId) {
                    await performVirtualAction(actionId);
                }

                await avatarPlatform.writeText(content, {
                    nlp: false
                });

                console.log(`✅ 虚拟人讲解第${pageNum}页，动作: ${actionId}`);

                updateSubtitle(content);
            } catch (error) {
                console.error('❌ 虚拟人讲解失败:', error);
            }
        }

        function updateSubtitle(text) {
            const subtitleArea = document.getElementById('subtitleArea');
            if (subtitleArea) {
                subtitleArea.textContent = text;
            }
        }

        function nextPage() {
            if (currentPage < totalPages) {
                switchToPage(currentPage + 1);
            }
        }
        function previousPage() {
            if (currentPage > 1) {
                switchToPage(currentPage - 1);
            }
        }
        function restart() { switchToPage(1); }
        function updatePageInfo() {
            document.getElementById('currentPage').textContent = currentPage;
        }

        function getPageTitle(pageNum) {
            return boardContent[pageNum - 1]?.title || `第${pageNum}页`;
        }

        // 自动播放功能
        let isAutoPlaying = false;
        async function startAutoPlay() {
            if (isAutoPlaying) {
                stopAutoPlay();
                return;
            }

            try {
                console.log('🎬 开始自动播放完整课程...');
                isAutoPlaying = true;

                const autoPlayBtn = document.getElementById('autoPlayBtn');
                autoPlayBtn.textContent = '⏹️ 停止播放';
                autoPlayBtn.style.background = 'linear-gradient(135deg, #f44336, #d32f2f)';

                updateStatus(`🎬 自动播放将在 1 秒后开始，请准备录屏！`, 'connecting');
                await new Promise(resolve => setTimeout(resolve, 1000));

                updateStatus('🎬 自动播放开始！', 'connected');
                document.body.classList.add('recording-mode');

                if (!avatarPlatform || !isConnected) {
                    console.log('🎬 启动虚拟人...');
                    await startTeaching();
                    await new Promise(resolve => setTimeout(resolve, 2000));
                }

                for (let page = 1; page <= totalPages; page++) {
                    try {
                        if (!isAutoPlaying) break;

                        console.log(`\n🎬 === 开始播放第${page}页/${totalPages}页 ===`);

                        switchToPageSilent(page);
                        updateStatus(`📖 第${page}页/${totalPages}页 - ${getPageTitle(page)}`, 'connected');

                        await new Promise(resolve => setTimeout(resolve, 800));

                        if (isConnected && isTeaching && avatarPlatform) {
                            console.log(`🎵 播放第${page}页语音...`);
                            try {
                                await speakContent(page);
                                const pageTime = autoPlayDurations[page];
                                await new Promise(resolve => setTimeout(resolve, pageTime));
                            } catch (error) {
                                console.error(`❌ 第${page}页语音播放失败:`, error);
                                const pageTime = autoPlayDurations[page];
                                await new Promise(resolve => setTimeout(resolve, pageTime));
                            }
                        } else {
                            const pageTime = autoPlayDurations[page];
                            await new Promise(resolve => setTimeout(resolve, pageTime));
                        }

                        const waitTime = page === totalPages ? 2000 : 1000;
                        await new Promise(resolve => setTimeout(resolve, waitTime));

                    } catch (error) {
                        console.error(`❌ 第${page}页播放过程出错:`, error);
                        await new Promise(resolve => setTimeout(resolve, 2000));
                    }
                }

                if (isAutoPlaying) {
                    await new Promise(resolve => setTimeout(resolve, 3000));
                    stopAutoPlay();
                }

            } catch (error) {
                console.error('❌ 自动播放失败:', error);
                updateStatus('自动播放失败: ' + error.message, 'error');
                stopAutoPlay();
            }
        }

        function stopAutoPlay() {
            if (isAutoPlaying) {
                isAutoPlaying = false;
                window.playbackFinished = true;
                document.title = "PLAYBACK_FINISHED";
                console.log('🎉 播放完成！已修改标题为 PLAYBACK_FINISHED');
                document.body.classList.remove('recording-mode');

                const autoPlayBtn = document.getElementById('autoPlayBtn');
                autoPlayBtn.textContent = '🎬 自动播放';
                autoPlayBtn.style.background = 'linear-gradient(135deg, #2196f3, #1976d2)';

                console.log('⏹️ 自动播放已停止');
                updateStatus('自动播放已停止', 'normal');
            }
        }

        window.addEventListener('beforeunload', function() {
            if (isAutoPlaying) {
                stopAutoPlay();
            }

            if (avatarPlatform && isConnected) {
                avatarPlatform.stop();
            }
        });
  </script>
</body>
</html>
