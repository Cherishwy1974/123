<!DOCTYPE html>

<html lang="zh-CN">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>
   02_2.11_两个重要极限
  </title>
<link href="https://fonts.googleapis.com" rel="preconnect"/>
<link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect"/>
<link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;600;700&amp;display=swap" rel="stylesheet"/>
<script src="https://d3js.org/d3.v7.min.js">
</script>
<style>
   * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Noto Serif SC', serif;
            background: #1a1a2e;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
        }
        .blackboard {
            width: 100vw;
            height: 100vh;
            background: #1a1a2e;
            position: relative;
            border: 10px solid #795548;
            margin: 0;
        }
        /* 虚拟人显示区域 - 稍微下移，避免遮挡内容 */
        .avatar-container {
            position: fixed;
            top: 60%; left: 50%;
            transform: translate(-50%, -50%);
            width: 975px; height: 1105px;
            overflow: hidden; z-index: 50;
            pointer-events: none; background: transparent;
            border: none; box-shadow: none;
        }
        .wrapper {
            width: 100%; height: 100%;
            background: transparent; pointer-events: auto;
        }
        /* 教学内容区域 - 避让虚拟人，左右分布 */
        .content-area {
            position: absolute;
            top: 20px; left: 50px; right: 50px; bottom: 120px;
            z-index: 10; overflow: hidden;
        }
        .page {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            opacity: 0; visibility: hidden;
            transition: all 0.7s ease-in-out;
            padding: 20px;
            display: grid;
            grid-template-columns: 2fr 3fr; /* 调整比例，给图更大空间 */
            gap: 20px;
            align-items: center;
        }
        .page.active {
            opacity: 1; visibility: visible;
        }
        /* 封面页特殊样式 - 覆盖grid布局 */
        .page.cover-page {
            display: flex !important;
            grid-template-columns: none !important;
            padding: 0 !important;
            align-items: center !important;
            justify-content: center !important;
        }
        .page.cover-page > div {
            display: flex !important;
        }
        .chalk-text {
            color: #ffffff;
            font-family: 'Noto Serif SC', 'Source Han Serif SC', 'Source Han Serif CN',
                         'Songti SC', 'SimSun', '宋体', serif;
            text-rendering: optimizeLegibility;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        .page-title {
            font-size: 24px; font-weight: bold;
            color: #e1bee7; margin-bottom: 1rem;
        }
        .text-medium {
            font-size: 16px;
            margin-bottom: 0.8rem;
            line-height: 1.7;
            color: #f3e5f5;
            font-weight: 500;
        }
        .emphasis {
            color: #FF6B6B;
            font-size: 18px;
        }
        .text-medium p {
            margin-bottom: 1rem;
        }
        .text-medium strong {
            color: #81c784;
            font-weight: 600;
        }
        .graph-container {
            background: transparent;
            border: none;
            padding: 0;
            width: 100%; height: 100%;
            display: flex; justify-content: center; align-items: center;
        }
        /* 字幕区域 - 全宽显示，虚拟人不影响布局 */
        .subtitle-area {
            position: absolute;
            bottom: 20px; left: 50px; right: 50px;
            height: 50px; background: rgba(0,0,0,0.8);
            border-radius: 8px; display: flex;
            align-items: center; justify-content: center;
            z-index: 60; color: white;
            font-size: 0.9rem; text-align: center;
            padding: 0 20px; line-height: 1.4;
        }
        /* 左侧控制栏 */
        .control-bar {
            position: fixed;
            left: -9999px;
            top: 50%;
            transform: translateY(-50%);
            width: 270px;
            height: auto;
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(15px);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 12px;
            z-index: 200;
            border-radius: 0 20px 20px 0;
            padding: 25px 20px;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        .control-bar:hover { 
            left: -9999px; 
            box-shadow: 0 12px 40px rgba(0,0,0,0.3); 
        }
        .control-bar::before {
            content: '▶️';
            position: absolute;
            top: 50%;
            right: -30px;
            transform: translateY(-50%);
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            padding: 12px 8px;
            border-radius: 0 15px 15px 0;
            font-size: 0.9rem;
            writing-mode: vertical-lr;
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #333;
        }
        .btn {
            padding: 14px 22px;
            background: rgba(255, 255, 255, 0.25);
            color: #333;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            width: 100%;
            text-align: center;
            backdrop-filter: blur(5px);
            text-shadow: 0 1px 2px rgba(255,255,255,0.3);
        }
        .btn:hover { 
            background: rgba(255, 255, 255, 0.35); 
            transform: translateY(-3px); 
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2); 
        }
        .btn.primary { 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
            color: #fff; 
            text-shadow: 0 1px 2px rgba(0,0,0,0.3); 
        }
        .btn.primary:hover { 
            background: linear-gradient(135deg, #5a6fd8 0%, #6a4190 100%); 
            box-shadow: 0 8px 25px rgba(102,126,234,0.4); 
        }

        /* 坐标系样式 - 改为白色 */
        .viz-panel .axis path,
        .viz-panel .axis line {
            stroke: white;
            stroke-width: 2;
        }
        .viz-panel .axis text {
            fill: white;
            font-size: 18px;
        }
        .viz-panel .label {
            fill: white;
            font-size: 18px;
            font-weight: 500;
        }

        /* 连接状态指示器 - 默认隐藏 */
        .status-indicator {
            position: absolute;
            top: 10px; right: 10px;
            padding: 5px 10px;
            background: rgba(0,0,0,0.5);
            color: white; border-radius: 5px;
            font-size: 12px; z-index: 100;
            transition: opacity 0.3s ease;
            display: none; /* 默认隐藏红色提示 */
        }
        .status-indicator.connected { background: rgba(76, 175, 80, 0.8); }
        .status-indicator.recording {
            background: rgba(244, 67, 54, 0.8);
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .status-indicator.error { background: rgba(244, 67, 54, 0.8); }
        .status-indicator.connecting { background: rgba(255, 152, 0, 0.8); }

        /* 录制模式下隐藏状态指示器 */
        .recording-mode .status-indicator {
            opacity: 0; pointer-events: none;
        }
        /* 录制模式下隐藏控制栏 */
        .recording-mode .control-bar {
            left: -9999px; transition: left 0.5s ease;
        }
  </style>
</head>
<body>
<div class="blackboard">
<div class="status-indicator" id="statusIndicator">
    等待连接
   </div>
<div class="avatar-container">
<div class="wrapper" id="avatarWrapper">
</div>
</div>
<div class="content-area" id="contentArea">
<div class="page active cover-page" data-page="1">
<div style="display: flex !important; width: 100%; height: 100%; align-items: center; justify-content: center;">
<div style="flex: 1; text-align: center; padding: 2rem;">
<h1 style="font-size: 2.2rem; font-weight: bold; color: #f1c40f; text-shadow: 0 0 8px rgba(241, 196, 15, 0.5); margin-bottom: 1rem;">
        两个重要极限
       </h1>
<p style="font-size: 1.1rem; color: #9ca3af; margin-bottom: 1.5rem;">
        第2章 视频 2.5
       </p>
<div style="display: inline-block; text-align: left; margin-top: 1.5rem;">
<p style="font-size: 0.95rem; color: #e0e0e0; margin: 0.6rem 0;">
         ✓ 第一重要极限 lim(sinx/x)
        </p>
<p style="font-size: 0.95rem; color: #e0e0e0; margin: 0.6rem 0;">
         ✓ 第二重要极限 lim(1+1/x)^x
        </p>
<p style="font-size: 0.95rem; color: #e0e0e0; margin: 0.6rem 0;">
         ✓ 两个极限的推广形式
        </p>
<p style="font-size: 0.95rem; color: #e0e0e0; margin: 0.6rem 0;">
         ✓ 重要极限的典型应用
        </p>
</div>
</div>
<div style="flex: 1; display: flex; align-items: center; justify-content: center;">
<svg style="width: 100%; max-width: 500px; height: 400px;" viewbox="0 0 600 500">
<defs>
<lineargradient id="grad1" x1="0%" x2="100%" y1="0%" y2="100%">
<stop offset="0%" style="stop-color:#3498db;stop-opacity:1">
</stop>
<stop offset="100%" style="stop-color:#9b59b6;stop-opacity:1">
</stop>
</lineargradient>
</defs>
<text fill="url(#grad1)" font-family="serif" font-size="60" text-anchor="middle" x="300" y="120">
         lim
         <animate attributename="opacity" dur="2s" repeatcount="indefinite" values="0.5;1;0.5">
</animate>
</text>
<line stroke="#3498db" stroke-width="3" x1="100" x2="500" y1="250" y2="250">
</line>
<circle cx="500" cy="250" fill="#e74c3c" r="15">
<animate attributename="r" dur="2s" repeatcount="indefinite" values="10;20;10">
</animate>
</circle>
<path d="M 100 250 Q 300 150 500 250" fill="none" stroke="#2ecc71" stroke-width="3">
<animate attributename="stroke-dasharray" dur="3s" repeatcount="indefinite" values="0,1000;1000,0">
</animate>
</path>
<text fill="#e74c3c" font-size="24" text-anchor="middle" x="500" y="300">
         x→x₀
        </text>
</svg>
</div>
</div>
</div>

<!-- Pages will be dynamically generated here -->
</div>
<div class="subtitle-area" id="subtitleArea">
    欢迎学习两个重要极限!点击"开始讲课"启动虚拟人讲师。
   </div>
<div class="control-bar">
<div style="color: white; margin-bottom: 1rem; text-align: center; font-size: 12px;">
     第
     <span id="currentPage">
      1
     </span>
     页 / 共
     <span id="totalPages">
      7
     </span>
     页
    </div>
<div id="connectionStatus" style="color: #ffab40; margin-bottom: 1rem; text-align: center; font-size: 11px;">
     虚拟人未连接
    </div>
<button class="btn" onclick="previousPage()">
     ⬅️ 上一页
    </button>
<button class="btn primary" id="startBtn" onclick="startTeaching()">
     🎀 开始讲课
    </button>
<button class="btn" onclick="nextPage()">
     下一页 ➡️
    </button>
<button class="btn" onclick="restart()">
     🔄 重新开始
    </button>
<button class="btn" id="autoPlayBtn" onclick="startAutoPlay()" style="background: linear-gradient(135deg, #2196f3, #1976d2);">
     🎬 自动播放
    </button>
<div style="color: #ffab40; margin-top: 0.5rem; text-align: center; font-size: 10px; line-height: 1.2;">
     💡 录制提示:
     <br/>
     点击自动播放后立即开始录屏
     <br/>
     系统会自动完成全部演示
    </div>
</div>
</div>
<script>
   window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                packages: ['base', 'ams']
            },
            startup: {
                pageReady: () => {
                    console.log('MathJax is ready.');
                    return MathJax.startup.defaultPageReady();
                }
            }
        };
  </script>
<script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
<!-- 讯飞官方SDK - 按照成功案例的加载方式 -->
<script type="module">
        // 播放完成标记（供OBS检测）
        window.playbackFinished = false;

   try {
                    // 根据成功案例,导入讯飞官方SDK
        const { default: AvatarPlatform, SDKEvents, PlayerEvents, RecorderEvents, UserMedia } = await import('./avatar-sdk-web_3.1.2.1002/index.js');

        // 挂载到全局对象
        window.AvatarPlatform = AvatarPlatform;
        window.SDKEvents = SDKEvents;
        window.PlayerEvents = PlayerEvents;
        window.RecorderEvents = RecorderEvents;
        window.UserMedia = UserMedia;

        console.log('✅ 讯飞官方SDK模块已加载');
        console.log('SDK版本:', AvatarPlatform.getVersion());
        console.log('可用事件:', { SDKEvents, PlayerEvents, RecorderEvents });

    } catch (error) {
        console.error('❌ SDK模块加载失败:', error);
        throw error; // 直接抛出错误,不使用模拟SDK
    }

        // 触发自定义事件,通知SDK已准备就绪
        window.dispatchEvent(new CustomEvent('sdkReady'));
  </script>
<script>
   let avatarPlatform = null;
        let isConnected = false;
        let isTeaching = false;
        let currentPage = 1;
        const totalPages = 7;

        // 简化的教学内容 - 避免截断
        const boardContent = [
            {
                title: "第一重要极限",
                text: "<p><strong>核心公式:</strong></p><p>$\\lim\\limits_{x \\to 0} \\frac{\\sin x}{x} = 1$</p><p><strong>特点分析:</strong></p><ul><li>这是一个 <span class='highlight'>$\\frac{0}{0}$ 型未定式</span></li><li>当 $x \\to 0$ 时,$\\sin x \\to 0$,$x \\to 0$</li><li>但比值的极限存在且等于1</li></ul><p><strong>几何意义:</strong><br>在单位圆中,当圆心角很小时,弧长、正弦值和角度趋于相等。</p><p><strong>重要性:</strong>这是三角函数求导的理论基础。</p>"
            },
            {
                title: "第一重要极限的推广",
                text: "<p><strong>核心思想:</strong>只要一个整体 $\\Delta$ 趋向于 0,那么 $\\frac{\\sin(\\Delta)}{\\Delta}$ 的极限就是 1。</p><p><strong>推广公式:</strong></p><p>$\\lim\\limits_{\\Delta \\to 0} \\frac{\\sin(\\Delta)}{\\Delta} = 1$</p><p><strong>应用实例:</strong></p><ul><li>当 $x \\to 1$ 时,$(x-1) \\to 0$:$\\lim\\limits_{x \\to 1} \\frac{\\sin(x - 1)}{x - 1} = 1$</li><li>当 $x \\to 0$ 时,$3x \\to 0$:$\\lim\\limits_{x \\to 0} \\frac{\\sin 3x}{3x} = 1$</li></ul><p><strong>解题技巧:</strong>识别 \"整体\" 是关键。</p>"
            },
            {
                title: "第二重要极限",
                text: "<p><strong>核心公式:</strong></p><p>$\\lim\\limits_{x \\to \\infty} \\left(1 + \\frac{1}{x}\\right)^x = e$</p><p><strong>特点分析:</strong></p><ul><li>这是一个 <span class='highlight'>$1^{\\infty}$ 型未定式</span></li><li>当 $x \\to \\infty$ 时,$(1+\\frac{1}{x}) \\to 1$,指数 $x \\to \\infty$</li><li>极限值是自然对数的底 $e \\approx 2.71828$</li></ul><p><strong>数学意义:</strong></p><ul><li>定义了自然对数的底数 $e$</li><li>连续复利计算的理论基础</li><li>指数函数和对数函数的重要纽带</li></ul><p><strong>实际应用:</strong>银行复利、人口增长模型等。</p>"
            },
            {
                title: "第二重要极限的推广",
                text: "<p><strong>核心思想:</strong>只要一个整体 $\\Delta$ 趋向于 $\\infty$,那么 $(1+\\frac{1}{\\Delta})^{\\Delta}$ 的极限就是 $e$。</p><p><strong>推广公式:</strong></p><p>$\\lim\\limits_{\\Delta \\to \\infty} \\left(1 + \\frac{1}{\\Delta}\\right)^{\\Delta} = e$</p><p><strong>变形形式:</strong></p><ul><li>当 $u \\to 0$ 时:$\\lim\\limits_{u \\to 0} (1 + u)^{\\frac{1}{u}} = e$</li><li>更一般的形式:$\\lim\\limits_{n \\to \\infty} \\left(1 + \\frac{k}{n}\\right)^n = e^k$</li></ul><p><strong>记忆技巧:</strong>\"1加什么分之一,再开什么次方,极限都是e\"</p>"
            },
            {
                title: "第一重要极限总结",
                text: "<p><strong>标准形式:</strong></p><p>$\\lim\\limits_{\\Delta \\to 0} \\frac{\\sin(\\Delta)}{\\Delta} = 1$</p><p><strong>适用条件:</strong></p><ul><li>分子含有正弦函数</li><li>分母与正弦函数的自变量相同</li><li>该自变量趋向于0</li></ul><p><strong>解题步骤:</strong></p><ul><li>1. 识别正弦函数中的\"整体\"</li><li>2. 确认该\"整体\"趋向于0</li><li>3. 构造标准形式</li><li>4. 直接应用公式</li></ul><p><strong>常见变形:</strong> $\\frac{\\sin kx}{kx}$、$\\frac{\\tan x}{x}$、$\\frac{\\arcsin x}{x}$ 等</p>"
            },
            {
                title: "第二重要极限总结",
                text: "<p><strong>标准形式:</strong></p><p>$\\lim\\limits_{\\Delta \\to \\infty} \\left(1 + \\frac{1}{\\Delta}\\right)^{\\Delta} = e$</p><p><strong>适用条件:</strong></p><ul><li>底数形如 $(1 + \\frac{1}{\\Delta})$</li><li>指数为 $\\Delta$</li><li>$\\Delta$ 趋向于无穷大</li></ul><p><strong>解题步骤:</strong></p><ul><li>1. 识别底数中的\"整体\"变量</li><li>2. 确认该变量趋向于无穷大</li><li>3. 将表达式化为标准形式</li><li>4. 直接应用公式得到 $e$</li></ul><p><strong>实际意义:</strong>复利计算、自然增长模型的数学基础。</p>"
            }
        ];

        const subtitleScript = {
            1: "同学们好,今天我们来学习两个在微积分中占据核心地位的重要极限。掌握它们,是解决许多复杂极限问题的基础,也是后续学习导数和积分的重要工具。它们分别用于解决0比0型和1的无穷大次幂型未定式。",
            2: "首先是第一重要极限。当自变量x无限趋近于0时,正弦函数sinx与x的比值,其极限为1。这是一个经典的0比0型未定式,但它的结果是确定的,就是1。右侧图像显示了函数的变化趋势。这个极限有着深刻的几何意义,是三角函数求导的理论基础。",
            3: "第一重要极限有一个非常实用的推广形式。核心思想是:只要一个整体趋向于0,那么这个整体的正弦与这个整体的比值,极限就为1。比如当x趋向于1时,x减1就趋向于0,所以可以直接应用。识别整体是解题的关键技巧。",
            4: "接下来是第二重要极限。当x趋向无穷大时,1加x分之1的x次方,它的极限是自然对数的底数e,约等于2.718。这是一个1的无穷大次幂型未定式。这个极限定义了自然对数的底数,是连续复利计算和自然增长模型的理论基础。",
            5: "第二重要极限也有推广形式。只要一个整体趋向于无穷大,那么1加整体分之1的整体次方,极限就是e。这个推广让我们能够处理更多复杂的情况,在实际应用中非常有用。",
            6: "我们来总结一下解题方法。对于第一重要极限,要识别sin整体除以整体的结构,确认整体趋向于0,然后直接应用公式。对于第二重要极限,要识别1加整体分之1的整体次方的结构,确认整体趋向于无穷大。解题的核心是把复杂表达式看作整体。",
            7: "最后我们看一些实际应用。第一重要极限可以用来处理正切函数、反正弦函数等相关的极限问题。第二重要极限在复利计算、人口增长、放射性衰变等模型中都有重要应用。这两个极限是微积分的重要工具,熟练掌握它们能解决很多实际问题。"
        };

        const autoPlayDurations = { 1: 15000, 2: 20000, 3: 18000, 4: 20000, 5: 15000, 6: 20000, 7: 18000 };

        // 状态更新函数
        function updateStatus(message, type = 'normal') {
            const indicator = document.getElementById('statusIndicator');
            const connectionStatus = document.getElementById('connectionStatus');

            if (indicator) {
                indicator.textContent = message;
                indicator.className = 'status-indicator';
                if (type === 'connected') {
                    indicator.classList.add('connected');
                } else if (type === 'error') {
                    indicator.classList.add('error');
                } else if (type === 'connecting') {
                    indicator.classList.add('connecting');
                }
            }

            if (connectionStatus) {
                connectionStatus.textContent = message;
                connectionStatus.style.color = type === 'connected' ? '#81c784' :
                                              type === 'error' ? '#f44336' : '#ffab40';
            }
        }

        // 等待SDK加载完成
        function waitForSDK() {
            return new Promise((resolve, reject) => {
                if (typeof AvatarPlatform !== 'undefined') {
                    resolve();
                    return;
                }

                const timeout = setTimeout(() => {
                    reject(new Error('SDK加载超时,请刷新页面重试'));
                }, 10000);

                window.addEventListener('sdkReady', function handler() {
                    clearTimeout(timeout);
                    window.removeEventListener('sdkReady', handler);
                    resolve();
                });
            });
        }

        document.addEventListener('DOMContentLoaded', () => {
            const contentArea = document.getElementById('contentArea');
            
            // 封面页已经在HTML中存在，不需要动态创建

            // 创建内容页
            boardContent.forEach((content, i) => {
                const page = document.createElement('div');
                page.className = 'page';
                page.dataset.page = i + 2;
                page.innerHTML = `
                    <div class="chalk-text">
                        <div class="page-title">${content.title}</div>
                        <div class="text-medium">${content.text}</div>
                    </div>
                    <div class="graph-container">
                        <svg id="viz-${i+2}" width="100%" height="100%"></svg>
                    </div>
                `;
                contentArea.appendChild(page);
            });

            // 设置总页数（+1因为有封面）
            document.getElementById('totalPages').textContent = totalPages + 1;
            switchToPage(1, false);
            console.log('✨ 两个重要极限教学系统初始化完成');

            // 🚀 自动启动播放 - 延迟3秒后自动开始
            setTimeout(() => {
                console.log('🚀 自动启动播放...');
                startAutoPlay();
            }, 3000);
        });

        function switchToPage(pageNum, shouldSpeak = true) {
            if (pageNum < 1 || pageNum > totalPages + 1) return;
            currentPage = pageNum;
            document.querySelectorAll('.page').forEach(p => {
                p.classList.remove('active');
                p.style.display = 'none';
            });
            const activeSlide = document.querySelector(`[data-page="${pageNum}"]`);
            if (activeSlide) {
                activeSlide.style.display = 'grid';
                requestAnimationFrame(() => {
                    activeSlide.classList.add('active');
                    drawPageGraph(pageNum);
                    if(window.MathJax && typeof window.MathJax.typeset === 'function') {
                        window.MathJax.typeset();
                    }
                });
            }
            updatePageInfo();
            if (shouldSpeak && !isAutoPlaying) {
                speakContent(pageNum);
            }
        }

        // 静默页面切换 - 不播放语音,专用于自动播放
        function switchToPageSilent(pageNum) {
            if (pageNum < 1 || pageNum > totalPages) {
                console.log(`❌ 页面切换失败:页码${pageNum}超出范围(1-${totalPages})`);
                return;
            }

            console.log(`🔄 开始切换到第${pageNum}页...`);

            const allPages = document.querySelectorAll('.page');
            allPages.forEach(page => {
                page.classList.remove('active');
                page.style.display = 'none';
            });

            const targetPage = document.querySelector(`[data-page="${pageNum}"]`);
            if (targetPage) {
                targetPage.style.display = 'grid';
                currentPage = pageNum;
                updatePageInfo();
                console.log(`✅ 成功切换到第${pageNum}页`);

                targetPage.offsetHeight; // 触发重绘

                setTimeout(() => {
                    targetPage.classList.add('active');
                    drawPageGraph(pageNum);
                    console.log(`🎨 第${pageNum}页图像绘制完成`);
                }, 300);
            } else {
                console.log(`❌ 未找到第${pageNum}页的DOM元素`);
            }
        }

        function drawPageGraph(pageNum) {
            // 封面页（第1页）不需要绘制图像，已有静态SVG
            if (pageNum === 1) {
                console.log('✅ 第1页是封面页，跳过图像绘制');
                return;
            }

            const svg = d3.select(`#viz-${pageNum}`);
            if (svg.empty()) {
                console.log(`⚠️ 未找到#viz-${pageNum}的SVG元素`);
                return;
            }

            svg.selectAll("*").remove();

            const container = svg.node().parentNode;
            const width = container.clientWidth;
            const height = container.clientHeight;
            svg.attr('viewBox', `0 0 ${width} ${height}`);

            switch(pageNum) {
                case 2: drawSinXOverXGraph(svg, width, height); break;
                case 3: drawGeneralSinGraph(svg, width, height); break;
                case 4: drawEGraph(svg, width, height); break;
                case 5: drawGeneralEGraph(svg, width, height); break;
                case 6: drawConclusionGraph1(svg, width, height); break;
                case 7: drawConclusionGraph2(svg, width, height); break;
            }
        }

        function drawIntroGraph(svg, width, height) {
            const lim1 = svg.append("foreignObject")
                .attr("x", width / 2 - 200)
                .attr("y", height / 2 - 100)
                .attr("width", 400)
                .attr("height", 60)
                .append("xhtml:div")
                .style("font-size", "22px")
                .style("color", "#81c784")
                .style("text-align", "center")
                .style("font-weight", "bold")
                .html("$ \\lim\\limits_{x \\to 0} \\frac{\\sin x}{x} = 1 $");

            const lim2 = svg.append("foreignObject")
                .attr("x", width / 2 - 200)
                .attr("y", height / 2 + 20)
                .attr("width", 400)
                .attr("height", 60)
                .append("xhtml:div")
                .style("font-size", "22px")
                .style("color", "#ffab40")
                .style("text-align", "center")
                .style("font-weight", "bold")
                .html("$ \\lim\\limits_{x \\to \\infty} \\left(1 + \\frac{1}{x}\\right)^x = e $");

            lim1.style("opacity", 0).transition().duration(1000).delay(500).style("opacity", 1);
            lim2.style("opacity", 0).transition().duration(1000).delay(1000).style("opacity", 1);
            setTimeout(() => { if(window.MathJax && typeof window.MathJax.typeset === 'function') window.MathJax.typeset(); }, 100);
        }

        function drawSinXOverXGraph(svg, width, height) {
            const margin = { top: 50, right: 50, bottom: 50, left: 50 };
            const w = width - margin.left - margin.right;
            const h = height - margin.top - margin.bottom;
            const g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);

            const x = d3.scaleLinear().domain([-6, 6]).range([0, w]);
            const y = d3.scaleLinear().domain([-0.5, 1.5]).range([h, 0]);

            // 白色坐标轴
            const xAxis = g.append("g").attr("transform", `translate(0,${y(0)})`).call(d3.axisBottom(x));
            xAxis.selectAll("path, line").attr("stroke", "white").attr("stroke-width", 2);
            xAxis.selectAll("text").attr("fill", "white").attr("font-size", "14px");

            const yAxis = g.append("g").attr("transform", `translate(${x(0)},0)`).call(d3.axisLeft(y));
            yAxis.selectAll("path, line").attr("stroke", "white").attr("stroke-width", 2);
            yAxis.selectAll("text").attr("fill", "white").attr("font-size", "14px");

            // y=1的参考线
            g.append("line").attr("x1", 0).attr("x2", w).attr("y1", y(1)).attr("y2", y(1))
                .attr("stroke", "#e1bee7").attr("stroke-width", 2).attr("stroke-dasharray", "5,5");
            g.append("text").attr("x", x(4.5)).attr("y", y(1.1)).text("y = 1")
                .attr("fill", "#e1bee7").attr("font-size", "16px");

            // sin(x)/x函数曲线
            const func = d => d === 0 ? 1 : Math.sin(d) / d;
            const line = d3.line().x(d => x(d)).y(d => y(func(d)));
            g.append("path").datum(d3.range(-6, 6, 0.1).filter(d => Math.abs(d) > 0.01))
                .attr("fill", "none").attr("stroke", "#81c784").attr("stroke-width", 3).attr("d", line);

            // 在x=0处画一个特殊点
            g.append("circle").attr("cx", x(0)).attr("cy", y(1)).attr("r", 6)
                .attr("fill", "#81c784").attr("stroke", "white").attr("stroke-width", 2);

            // 动画点
            const dot = g.append("circle").attr("r", 8).attr("fill", "#ffab40");

            function animate() {
                const startX = -5, endX = 5;
                const interpolator = d3.interpolate(startX, endX);
                dot.transition().duration(4000).ease(d3.easeCubicInOut)
                   .attrTween("cx", () => t => x(interpolator(t)))
                   .attrTween("cy", () => t => {
                       const currentX = interpolator(t);
                       return y(Math.abs(currentX) < 0.01 ? 1 : func(currentX));
                   })
                   .on("end", () => {
                       const backInterpolator = d3.interpolate(endX, startX);
                       dot.transition().duration(4000).ease(d3.easeCubicInOut)
                          .attrTween("cx", () => t => x(backInterpolator(t)))
                          .attrTween("cy", () => t => {
                              const currentX = backInterpolator(t);
                              return y(Math.abs(currentX) < 0.01 ? 1 : func(currentX));
                          })
                          .on("end", animate);
                   });
            }
            animate();
        }

        function drawGeneralSinGraph(svg, width, height) {
            const centerX = width / 2;
            const centerY = height / 2;

            // 更大更清晰的框和文字
            const box = svg.append("rect").attr("x", centerX - 120).attr("y", centerY - 180)
                .attr("width", 240).attr("height", 120).attr("fill", "#2d3748")
                .attr("stroke", "#ffab40").attr("stroke-width", 4).attr("rx", 8);
            const boxText = svg.append("text").attr("x", centerX).attr("y", centerY - 120)
                .text("Δ").attr("font-size", "64px").attr("fill", "#ffab40")
                .attr("text-anchor", "middle").attr("dominant-baseline", "middle")
                .attr("font-weight", "bold");

            // 更清晰的箭头
            const arrow = svg.append("text").attr("x", centerX).attr("y", centerY - 30)
                .text("↓").attr("font-size", "56px").attr("fill", "#ffffff")
                .attr("text-anchor", "middle").attr("font-weight", "bold");
            const zeroText = svg.append("text").attr("x", centerX).attr("y", centerY + 50)
                .text("0").attr("font-size", "64px").attr("fill", "#ffffff")
                .attr("text-anchor", "middle").attr("font-weight", "bold");

            // 更清晰的公式
            const formula = svg.append("foreignObject").attr("x", 0).attr("y", centerY + 120)
                .attr("width", width).attr("height", 120)
                .append("xhtml:div").style("font-size", "42px").style("color", "#81c784")
                .style("text-align", "center").style("font-weight", "bold")
                .html("$ \\frac{\\sin(\\Delta)}{\\Delta} \\to 1 $");

            // 动画序列
            box.attr("opacity", 0).transition().duration(1000).attr("opacity", 1);
            boxText.attr("opacity", 0).transition().duration(1000).attr("opacity", 1);
            arrow.attr("opacity", 0).transition().delay(500).duration(1000).attr("opacity", 1);
            zeroText.attr("opacity", 0).transition().delay(1000).duration(1000).attr("opacity", 1);
            formula.style("opacity", 0).transition().delay(1500).duration(1000).style("opacity", 1);
            setTimeout(() => { if(window.MathJax && typeof window.MathJax.typeset === 'function') window.MathJax.typeset(); }, 100);
        }

        function drawEGraph(svg, width, height) {
            const margin = { top: 50, right: 50, bottom: 50, left: 60 };
            const w = width - margin.left - margin.right;
            const h = height - margin.top - margin.bottom;
            const g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);

            const x = d3.scaleLinear().domain([0, 20]).range([0, w]);
            const y = d3.scaleLinear().domain([1, 3]).range([h, 0]);

            // 白色坐标轴
            const xAxis = g.append("g").attr("transform", `translate(0,${y(1)})`).call(d3.axisBottom(x));
            xAxis.selectAll("path, line").attr("stroke", "white").attr("stroke-width", 2);
            xAxis.selectAll("text").attr("fill", "white").attr("font-size", "14px");

            const yAxis = g.append("g").call(d3.axisLeft(y));
            yAxis.selectAll("path, line").attr("stroke", "white").attr("stroke-width", 2);
            yAxis.selectAll("text").attr("fill", "white").attr("font-size", "14px");

            const e = Math.E;
            // y=e的参考线
            g.append("line").attr("x1", 0).attr("x2", w).attr("y1", y(e)).attr("y2", y(e))
                .attr("stroke", "#e1bee7").attr("stroke-width", 2).attr("stroke-dasharray", "5,5");
            g.append("text").attr("x", x(12)).attr("y", y(e - 0.1)).text("y = e ≈ 2.718")
                .attr("fill", "#e1bee7").attr("font-size", "16px");

            // (1+1/x)^x函数曲线
            const func = d => Math.pow(1 + 1/d, d);
            const line = d3.line().x(d => x(d)).y(d => y(func(d)));
            g.append("path").datum(d3.range(0.5, 20, 0.2))
                .attr("fill", "none").attr("stroke", "#ffab40").attr("stroke-width", 3).attr("d", line);

            // 动画点
            const dot = g.append("circle").attr("r", 8).attr("fill", "#ffab40");

            function animate() {
                const startX = 1, endX = 20;
                const interpolator = d3.interpolate(startX, endX);
                dot.transition().duration(5000).ease(d3.easeLinear)
                   .attrTween("cx", () => t => x(interpolator(t)))
                   .attrTween("cy", () => t => y(func(interpolator(t))))
                   .on("end", () => {
                       const backInterpolator = d3.interpolate(endX, startX);
                       dot.transition().duration(3000).ease(d3.easeLinear)
                          .attrTween("cx", () => t => x(backInterpolator(t)))
                          .attrTween("cy", () => t => y(func(backInterpolator(t))))
                          .on("end", animate);
                   });
            }
            animate();
        }

        function drawGeneralEGraph(svg, width, height) {
            const centerX = width / 2;
            const centerY = height / 2;

            // 更大更清晰的框和文字
            const box = svg.append("rect").attr("x", centerX - 120).attr("y", centerY - 180)
                .attr("width", 240).attr("height", 120).attr("fill", "#2d3748")
                .attr("stroke", "#ffab40").attr("stroke-width", 4).attr("rx", 8);
            const boxText = svg.append("text").attr("x", centerX).attr("y", centerY - 120)
                .text("Δ").attr("font-size", "64px").attr("fill", "#ffab40")
                .attr("text-anchor", "middle").attr("dominant-baseline", "middle")
                .attr("font-weight", "bold");

            // 更清晰的箭头
            const arrow = svg.append("text").attr("x", centerX).attr("y", centerY - 30)
                .text("↓").attr("font-size", "56px").attr("fill", "#ffffff")
                .attr("text-anchor", "middle").attr("font-weight", "bold");
            const infText = svg.append("text").attr("x", centerX).attr("y", centerY + 50)
                .text("∞").attr("font-size", "64px").attr("fill", "#ffffff")
                .attr("text-anchor", "middle").attr("font-weight", "bold");

            // 更清晰的公式
            const formula = svg.append("foreignObject").attr("x", 0).attr("y", centerY + 120)
                .attr("width", width).attr("height", 120)
                .append("xhtml:div").style("font-size", "36px").style("color", "#ffab40")
                .style("text-align", "center").style("font-weight", "bold")
                .html("$ \\left(1 + \\frac{1}{\\Delta}\\right)^{\\Delta} \\to e $");

            // 动画序列
            box.attr("opacity", 0).transition().duration(1000).attr("opacity", 1);
            boxText.attr("opacity", 0).transition().duration(1000).attr("opacity", 1);
            arrow.attr("opacity", 0).transition().delay(500).duration(1000).attr("opacity", 1);
            infText.attr("opacity", 0).transition().delay(1000).duration(1000).attr("opacity", 1);
            formula.style("opacity", 0).transition().delay(1500).duration(1000).style("opacity", 1);
            setTimeout(() => { if(window.MathJax && typeof window.MathJax.typeset === 'function') window.MathJax.typeset(); }, 100);
        }

        function drawConclusionGraph1(svg, width, height) {
             const g = svg.append("g").attr("transform", `translate(${width/2}, ${height/2})`);
             const text = g.append("foreignObject").attr("x", -width/2).attr("y", -80)
                .attr("width", width).attr("height", 160)
                .append("xhtml:div").style("font-size", "32px").style("color", "#81c784")
                .style("text-align", "center").style("font-weight", "bold")
                .html("$ \\lim\\limits_{\\Delta \\to 0} \\frac{\\sin(\\Delta)}{\\Delta} = 1 $");
             setTimeout(() => { if(window.MathJax && typeof window.MathJax.typeset === 'function') window.MathJax.typeset(); }, 100);
             text.style("opacity", 0).transition().duration(1000).style("opacity", 1);
        }

        function drawConclusionGraph2(svg, width, height) {
             const g = svg.append("g").attr("transform", `translate(${width/2}, ${height/2})`);
             const text = g.append("foreignObject").attr("x", -width/2).attr("y", -80)
                .attr("width", width).attr("height", 160)
                .append("xhtml:div").style("font-size", "32px").style("color", "#ffab40")
                .style("text-align", "center").style("font-weight", "bold")
                .html("$ \\lim\\limits_{\\Delta \\to \\infty} \\left(1 + \\frac{1}{\\Delta}\\right)^{\\Delta} = e $");
             setTimeout(() => { if(window.MathJax && typeof window.MathJax.typeset === 'function') window.MathJax.typeset(); }, 100);
             text.style("opacity", 0).transition().duration(1000).style("opacity", 1);
        }

        // 虚拟人控制 - 使用正确的配置
        async function startTeaching() {
            const startBtn = document.getElementById('startBtn');
            startBtn.textContent = '🔄 启动中...';
            startBtn.disabled = true;

            try {
                console.log('⏳ 等待SDK模块加载...');
                updateStatus('等待SDK加载...', 'connecting');
                await waitForSDK();

                console.log('✅ 讯飞官方SDK已加载');
                updateStatus('SDK已加载', 'connecting');

                if(avatarPlatform) {
                    avatarPlatform.destroy();
                }

                // 创建虚拟人实例
                avatarPlatform = new AvatarPlatform({
                    useInlinePlayer: true
                });

                // 设置事件监听
                avatarPlatform
                    .on('connected', (initResp) => {
                        console.log('🎉 虚拟人连接成功!', initResp);
                        isConnected = true;
                        isTeaching = true;
                        updateStatus('已连接', 'connected');
                        startBtn.textContent = '💖 虚拟人已就绪';
                        startBtn.disabled = false;

                        setTimeout(() => {
                            speakContent(1);
                        }, 1000);
                    })
                    .on('disconnected', (err) => {
                        console.log('🔌 虚拟人连接断开');
                        isConnected = false;
                        isTeaching = false;
                        updateStatus('连接断开', 'error');
                        startBtn.textContent = '🎀 开始讲课';
                        startBtn.disabled = false;
                        if (err) {
                            console.error('❌ 连接异常断开:', err);
                        }
                    })
                    .on('error', (error) => {
                        console.error('❌ 虚拟人错误:', error);
                        updateStatus('错误: ' + error.message, 'error');
                        startBtn.textContent = '❌ 连接失败';
                        startBtn.disabled = false;
                        isTeaching = false;
                        isConnected = false;
                    });

                // 使用正确的API配置
                avatarPlatform.setApiInfo({
                    appId: 'e8c180ed',                                    // 数学讲解 AppID
                    apiKey: 'e0c44f0e2ef0f47582ffa7e864da0d9b',             // 数学讲解 API密钥
                    apiSecret: 'MDZkNDNiZWU4NDkzNWM5MDQzMTY4N2Nh',       // 数学讲解 API密钥
                    sceneId: '237415046114840576',                       // 数学讲解 场景ID
                    serverUrl: 'wss://avatar.cn-huadong-1.xf-yun.com/v1/interact'
                });

                // 使用正确的全局参数
                avatarPlatform.setGlobalParams({
                    stream: {
                        protocol: 'xrtc',
                        alpha: 1,
                        bitrate: 1000000,
                        fps: 25
                    },
                    avatar: {
                        avatar_id: '110332017',
                        width: 1920,
                        height: 1080,
                        scale: 1,
                        move_h: 0,
                        move_v: 0,
                        audio_format: 1
                    },
                    tts: {
                        vcn: 'x4_yiting',
                        speed: 50,
                        pitch: 50,
                        volume: 100
                    },
                    avatar_dispatch: {
                        interactive_mode: 1,
                        content_analysis: 0
                    }
                });

                // 启动虚拟人
                await avatarPlatform.start({
                    wrapper: document.getElementById('avatarWrapper')
                });

                console.log('🎓 虚拟人教学系统启动完成');

            } catch (error) {
                console.error('❌ 启动失败:', error);
                updateStatus('启动失败', 'error');
                startBtn.textContent = '🔄 重试';
                startBtn.disabled = false;

                alert(`启动失败:${error.message}\n\n请检查控制台获取详细错误信息。`);
            }
        }

        // 动作执行
        async function performVirtualAction(actionId) {
            if (!isTeaching || !isConnected || !avatarPlatform) {
                console.log('⚠️ 虚拟人未连接,跳过动作执行');
                return;
            }

            try {
                await avatarPlatform.writeCmd("action", actionId);
                console.log(`✅ 执行动作: ${actionId}`);
            } catch (error) {
                console.error(`❌ 动作执行失败 (${actionId}):`, error);
            }
        }

        // 动作映射
        function getActionsForPage(pageNum) {
            const actionMap = {
                1: 'A_RLH_welcome_O',
                2: 'A_LH_introduced_O',
                3: 'A_RH_please1_O',
                4: 'A_RLH_emphasize_O',
                5: 'A_U_No_pointing_O',
                6: 'A_RLH_welcome_O',
                7: 'A_RH_please1_O'
            };
            return actionMap[pageNum];
        }

        // 语音播放
        async function speakContent(pageNum) {
            console.log(`🔍 检查播放条件: isTeaching=${isTeaching}, isConnected=${isConnected}, avatarPlatform=${!!avatarPlatform}`);

            if (!isTeaching || !isConnected || !avatarPlatform) {
                console.log('⚠️ 虚拟人未连接或未开始教学,跳过语音播报');
                return;
            }

            const content = subtitleScript[pageNum];
            if (!content) return;

            try {
                // 先执行动作
                const actionId = getActionsForPage(pageNum);
                if (actionId) {
                    await performVirtualAction(actionId);
                }

                // 然后播放语音内容
                await avatarPlatform.writeText(content, {
                    nlp: false
                });

                console.log(`✅ 虚拟人讲解第${pageNum}页,动作: ${actionId}`);

                // 更新字幕显示
                updateSubtitle(content);
            } catch (error) {
                console.error('❌ 虚拟人讲解失败:', error);
            }
        }

        // 更新字幕显示
        function updateSubtitle(text) {
            const subtitleArea = document.getElementById('subtitleArea');
            if (subtitleArea) {
                subtitleArea.textContent = text;
            }
        }

        // 页面控制函数
        function nextPage() {
            if (currentPage < totalPages) {
                switchToPage(currentPage + 1);
            }
        }
        function previousPage() {
            if (currentPage > 1) {
                switchToPage(currentPage - 1);
            }
        }
        function restart() { switchToPage(1); }
        function updatePageInfo() {
            document.getElementById('currentPage').textContent = currentPage;
        }

        // 获取页面标题
        function getPageTitle(pageNum) {
            return boardContent[pageNum - 1]?.title || `第${pageNum}页`;
        }

        // 自动播放功能
        let isAutoPlaying = false;
        async function startAutoPlay() {
            if (isAutoPlaying) {
                stopAutoPlay();
                return;
            }

            try {
                console.log('🎬 开始自动播放完整课程...');
                isAutoPlaying = true;

                const autoPlayBtn = document.getElementById('autoPlayBtn');
                autoPlayBtn.textContent = '⏹️ 停止播放';
                autoPlayBtn.style.background = 'linear-gradient(135deg, #f44336, #d32f2f)';

                updateStatus(`🎬 自动播放将在 1 秒后开始,请准备录屏!`, 'connecting');
                await new Promise(resolve => setTimeout(resolve, 1000));

                updateStatus('🎬 自动播放开始!', 'connected');
                document.body.classList.add('recording-mode');

                // 如果虚拟人未连接,在后台尝试连接
                if (!avatarPlatform || !isConnected) {
                    console.log('🎬 启动虚拟人...');
                    await startTeaching();
                    await new Promise(resolve => setTimeout(resolve, 2000));
                }

                // 逐页播放
                for (let page = 1; page <= totalPages; page++) {
                    try {
                        if (!isAutoPlaying) break;

                        console.log(`\n🎬 === 开始播放第${page}页/${totalPages}页 ===`);

                        switchToPageSilent(page);
                        updateStatus(`📖 第${page}页/${totalPages}页 - ${getPageTitle(page)}`, 'connected');

                        await new Promise(resolve => setTimeout(resolve, 800));

                        if (isConnected && isTeaching && avatarPlatform) {
                            console.log(`🎵 播放第${page}页语音...`);
                            try {
                                await speakContent(page);
                                const pageTime = autoPlayDurations[page];
                                await new Promise(resolve => setTimeout(resolve, pageTime));
                            } catch (error) {
                                console.error(`❌ 第${page}页语音播放失败:`, error);
                                const pageTime = autoPlayDurations[page];
                                await new Promise(resolve => setTimeout(resolve, pageTime));
                            }
                        } else {
                            const pageTime = autoPlayDurations[page];
                            await new Promise(resolve => setTimeout(resolve, pageTime));
                        }

                        const waitTime = page === totalPages ? 2000 : 1000;
                        await new Promise(resolve => setTimeout(resolve, waitTime));

                    } catch (error) {
                        console.error(`❌ 第${page}页播放过程出错:`, error);
                        await new Promise(resolve => setTimeout(resolve, 2000));
                    }
                }

                if (isAutoPlaying) {
                    await new Promise(resolve => setTimeout(resolve, 3000));
                    stopAutoPlay();
                }

            } catch (error) {
                console.error('❌ 自动播放失败:', error);
                updateStatus('自动播放失败: ' + error.message, 'error');
                stopAutoPlay();
            }
        }

        function stopAutoPlay() {
            if (isAutoPlaying) {
                isAutoPlaying = false;
                window.playbackFinished = true;
                document.title = "PLAYBACK_FINISHED";
                console.log('🎉 播放完成！已修改标题为 PLAYBACK_FINISHED');
                document.body.classList.remove('recording-mode');

                const autoPlayBtn = document.getElementById('autoPlayBtn');
                autoPlayBtn.textContent = '🎬 自动播放';
                autoPlayBtn.style.background = 'linear-gradient(135deg, #2196f3, #1976d2)';

                console.log('⏹️ 自动播放已停止');
                updateStatus('自动播放已停止', 'normal');
            }
        }

        // 页面关闭清理
        window.addEventListener('beforeunload', function() {
            if (isAutoPlaying) {
                stopAutoPlay();
            }

            if (avatarPlatform && isConnected) {
                avatarPlatform.stop();
            }
        });
  </script>
</body>
</html>
